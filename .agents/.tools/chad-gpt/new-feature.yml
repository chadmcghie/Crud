---
description: "Agent-OS Pack: Modes + Plan→Clean + Branch Reconciler"
version: 1.0
encoding: UTF-8

# =========================================
# Global env (tune in VS/CI)
# =========================================
<env>
  CLAUDE_PLANNING_MODEL: "claude-4-opus-latest"
  CLAUDE_EXECUTION_MODEL: "claude-4-5-sonnet-latest"
  BIG_CONTEXT_TOKEN_THRESHOLD: "100000"
  # Optional: budgets/guards you can wire into your runner
  CLAUDE_OPUS_MAX_COST_PER_TASK: "1.00"
  CLAUDE_OPUS_MAX_LATENCY_MS: "20000"
</env>

# =========================================
# Scaffolding: creates the helper files
# =========================================
<pre_flight_check>
  EXECUTE_TS: |
    // Create directories and write files needed by this pack
    import * as fs from "node:fs";
    import * as path from "node:path";

    function ensure(p: string) { fs.mkdirSync(p, { recursive: true }); }
    function write(file: string, content: string) {
      ensure(path.dirname(file));
      fs.writeFileSync(file, content, "utf8");
      ctx.logs?.info?.(`Wrote ${file}`);
    }

    // ---------- agent-os/lib/mode.ts ----------
    write("agent-os/lib/mode.ts", `
    export type Mode =
      | "planning" | "implementing" | "troubleshooting"
      | "documenting" | "free-balling" | "cleaning" | "reconciling";

    export function pushMode(ctx: any, mode: Mode) {
      ctx.mode_stack = ctx.mode_stack || [];
      ctx.mode_stack.push(ctx.mode);
      ctx.mode = mode;
      ctx.vars = { ...(ctx.vars||{}), mode };
    }
    export function popMode(ctx: any) {
      ctx.mode = (ctx.mode_stack || []).pop() || ctx.mode;
      ctx.vars = { ...(ctx.vars||{}), mode: ctx.mode };
    }
    `);

    // ---------- agent-os/lib/maturity.ts ----------
    write("agent-os/lib/maturity.ts", `
    export type Subscores = {
      cadence: number;   // 0..5
      security: number;  // 0..5
      ecosystem: number; // 0..5
      license: number;   // 0..5
      apiStable: number; // 0..5
      specFit: number;   // 0..5
    };
    export function adoptionRing(total: number) {
      if (total >= 22) return "Adopt";
      if (total >= 18) return "Trial";
      if (total >= 14) return "Assess";
      return "Hold";
    }
    export function bandFromRing(ring: string) {
      return ({ Adopt: "Established", Trial: "Mainstream", Assess: "Emerging", Hold: "Experimental" } as any)[ring] || "Emerging";
    }
    `);

    // ---------- agent-os/prompts/mode-overlays.ts ----------
    write("agent-os/prompts/mode-overlays.ts", `
    export const MODE_OVERLAYS: Record<string, string> = {
      planning: \`
You are in PLANNING mode.
Goal: Evaluate whether our current packages (npm + NuGet) and plausible alternatives best satisfy the target specs. Then propose options with risk↔reward tradeoffs.
Do this:
1) Inventory current deps (npm + NuGet) relevant to the scope.
2) For each package: summarize core features vs our spec, note gaps, and map to adoption ring (Adopt/Trial/Assess/Hold).
3) Research latest best practices & ecosystem direction (recent 12–24 months) and cite sources.
4) Score maturity & risk using the rubric (cadence, security, ecosystem, license, API stability, spec fit 0–5 each).
5) Present 2–4 options (keep/upgrade/switch/build) with risk, effort, impact; mark the default.
Output: a concise matrix, then a short recommendation.
\`,
      implementing: \`
You are in IMPLEMENTING mode.
- Ship minimal, correct code with tests. Keep explanations terse.
- Show essential snippets/diffs only. Include runnable commands.
\`,
      troubleshooting: \`
You are in TROUBLESHOOTING mode.
- Hypothesize -> test quickly. Isolate variables, minimize scope.
- End with the next 2 experiments.
\`,
      documenting: \`
You are in DOCUMENTING mode.
- Write scannable docs with context, purpose, how-to, gotchas; add examples.
\`,
      "free-balling": \`
You are in FREE-BALLING (brainstorm) mode.
- Diverge with multiple labeled directions, then converge to 1–2 picks + next steps.
\`,
      cleaning: \`
You are in CLEANING mode.
- Codebase hygiene: remove unused imports/files/deps/configs.
- Prefer low-risk, incremental changes; separate PRs per batch.
- Always show unified diffs and exact commands.
- Require evidence (usage search/call-graph) before deletion; note CI impacts.
\`,
      reconciling: \`
You are in RECONCILING (branch comparison) mode.
- Identify feature deltas; prefer the most advanced, stable implementation.
- Score standards/spec alignment, perf signals, and tests.
- For each delta: KEEP(base) | KEEP(head) | RECONCILE + 1–2 sentence rationale.
- Separate textual vs functional conflicts; output a precise merge plan.
\`,
    };
    `);

    // ---------- agent-os/steps/mode-router.ts ----------
    write("agent-os/steps/mode-router.ts", `
    import { estimateTokens } from "./token-estimator"; // optional hook if you have it
    type Mode = "planning" | "implementing" | "troubleshooting" | "documenting" | "free-balling" | "cleaning" | "reconciling";

    const KEYWORDS: Record<Mode, string[]> = {
      planning: ["plan","roadmap","decompose","milestones","architecture","design doc","scope","tradeoff","risk"],
      implementing: ["implement","code","refactor","scaffold","generate","write tests","migrate","create endpoint"],
      troubleshooting: ["troubleshoot","debug","root cause","flaky","incident","investigate","error","failure","regression"],
      documenting: ["document","docs","readme","spec","comment","guide","explain"],
      "free-balling": ["brainstorm","explore","ideas","blue-sky","ideate","sketch"],
      cleaning: ["clean","cleanup","dead code","tree-shake","remove unused","dependency upgrade","lint fix","maintenance","housekeeping"],
      reconciling: ["reconcile","branch compare","merge plan","conflict map","most advanced feature","feature delta"]
    };

    function extractExplicitMode(s: string): Mode | null {
      const m = (s || "").toLowerCase().match(/\\[mode:\\s*(planning|implementing|troubleshooting|documenting|free-balling|cleaning|reconciling)\\]/);
      return m ? (m[1] as Mode) : null;
    }
    function inferMode(text: string): Mode {
      const t = (text || "").toLowerCase();
      for (const mode of Object.keys(KEYWORDS) as Mode[]) {
        if (KEYWORDS[mode].some(k => t.includes(k))) return mode;
      }
      return "implementing";
    }
    function modelFor(mode: Mode, bigContext: boolean): string {
      const opus = process.env.CLAUDE_PLANNING_MODEL || "claude-3-opus-latest";
      const sonnet = process.env.CLAUDE_EXECUTION_MODEL || "claude-3-5-sonnet-latest";
      if (mode === "planning" || mode === "troubleshooting" || mode === "reconciling") return opus;
      if (bigContext) return opus;
      return sonnet;
    }

    export default async function modeRouter(ctx: any) {
      const text = [
        ctx.task?.name || "",
        ctx.task?.description || "",
        ...(ctx.tasks || []).map((t: any) => \`\${t.name || ""} \${t.description || ""}\`)
      ].join(" ");
      const explicit = extractExplicitMode(text);
      const inferred = inferMode(text);
      const mode: Mode = explicit ?? inferred;

      let bigContext = false;
      try {
        const threshold = parseInt(process.env.BIG_CONTEXT_TOKEN_THRESHOLD || "100000", 10);
        bigContext = (estimateTokens?.(ctx) || 0) > threshold;
      } catch {}

      const model = modelFor(mode, bigContext);
      ctx.mode = mode; ctx.model = model;
      ctx.vars = { ...(ctx.vars || {}), mode, model };
      ctx.logs?.info?.(\`Mode selected: \${mode}; Model: \${model}\${bigContext ? " (big-context override)" : ""}\`);
      return ctx;
    }
    `);

    // ---------- agent-os/steps/dependency-inventory.ts ----------
    write("agent-os/steps/dependency-inventory.ts", `
    import { execSync } from "node:child_process";
    export function npmInventory(cwd = ".") {
      try {
        const json = JSON.parse(execSync("node -e \\"console.log(JSON.stringify(require('./package.json')))\\\"", { cwd }).toString());
        const deps = { ...(json.dependencies||{}), ...(json.devDependencies||{}) };
        return Object.entries(deps).map(([name, version]) => ({ eco: "npm", name, version }));
      } catch { return []; }
    }
    export function nugetInventory(solutionDir = ".") {
      try {
        const out = execSync("dotnet list package --include-transitive", { cwd: solutionDir }).toString();
        const rows = out.split("\\n").filter(l => /\\s[A-Za-z0-9.\\-]+\\s+\\d/.test(l));
        return rows.map(line => {
          const parts = line.trim().split(/\\s+/);
          return { eco: "nuget", name: parts[0], version: parts[1] || "" };
        });
      } catch { return []; }
    }
    export default function collectDeps(ctx: any) {
      const npm = npmInventory(".");
      const nuget = nugetInventory(".");
      ctx.vars = { ...(ctx.vars||{}), dep_inventory: { npm, nuget } };
      return ctx;
    }
    `);

    // ---------- agent-os/steps/branch-collect.ts ----------
    write("agent-os/steps/branch-collect.ts", `
    import { execSync } from "node:child_process";
    import * as fs from "node:fs";
    export type CompareInput = { repo: string; base: string; head: string; feBuild?: boolean; dotnet?: boolean; };
    function sh(cmd: string, cwd: string) { return execSync(cmd, { cwd, stdio: "pipe" }).toString().trim(); }
    export default function collect(ci: CompareInput) {
      const { repo, base, head } = ci;
      const mergeBase = sh(\`git merge-base \${base} \${head}\`, repo);
      const diffStatBase = sh(\`git diff --stat \${mergeBase}...\${base}\`, repo);
      const diffStatHead = sh(\`git diff --stat \${mergeBase}...\${head}\`, repo);
      let conflictsDryRun = "";
      try { sh(\`git -c advice.detachedHead=false checkout \${base}\`, repo);
            sh(\`git merge --no-commit --no-ff \${head}\`, repo);
            sh(\`git merge --abort\`, repo);
      } catch {
            sh(\`git merge --abort || true\`, repo);
            conflictsDryRun = sh(\`git ls-files -u | cut -f2 | sort -u\`, repo);
      }
      const headCommitCount = parseInt(sh(\`git rev-list --count \${mergeBase}..\${head}\`, repo));
      const baseCommitCount = parseInt(sh(\`git rev-list --count \${mergeBase}..\${base}\`, repo));
      return { mergeBase, diffStatBase, diffStatHead, conflictsDryRun, headCommitCount, baseCommitCount };
    }
    `);
</pre_flight_check>

# =========================================
# Default LLM config (router will swap model)
# =========================================
<llm_config>
  provider: anthropic
  model: "{{ model }}"
  temperature: 0.2
  max_tokens: 4096
</llm_config>

# =========================================
# Flow A: Plan → Clean (mode-stacked)
# =========================================
<process_flow id="plan_clean">

<step number="0" name="mode_router">
  EXECUTE: @./agent-os/steps/mode-router.ts
</step>

<step number="0.5" name="gather_dependencies">
  EXECUTE: @./agent-os/steps/dependency-inventory.ts
</step>

<step number="1A" name="package_fit_and_landscape">
  # PLANNING (Opus) — includes web research + citations
  INVOKE_LLM:
    - system: |
        Active mode: planning
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['planning']") }}
        Research rules:
        - Prefer primary sources (official docs, maintainers, standards).
        - Add 1–2 reputable secondary sources (radars/foundations/NIST/OWASP).
        - Include 3–6 citations with dates; favor ≤24 months old.
        - If sources disagree, surface the disagreement explicitly.
      user: |
        Scope/spec to satisfy:
        {{ task.description }}

        Codebase inventory (npm/NuGet):
        {{ dep_inventory | json }}

        Deliver:
        1) Packages relevant to the scope (name@version, role).
        2) For each: spec-fit notes, adoption ring, maturity/risk sub-scores.
        3) Up to two alternatives per package with pros/cons + adoption ring.
        4) Risk↔reward **menu of choices** (keep / upgrade / switch / build) table,
           with a bold default pick and brief rationale.

</step>

<step number="1B" name="plan_validation_gate">
  INVOKE_LLM:
    - system: |
        You are a safety checker. If the plan deletes or replaces components without evidence,
        reply "BLOCKED: <reason>" and list minimal extra info needed.
      user: |
        Validate the plan above. If acceptable, list the 3 most critical pre-execution checks.

</step>

<step number="2" name="planning_phase_output">
  EXECUTE_TS: |
    // Persist planning artifacts for audit
    import * as fs from "node:fs"; import * as path from "node:path";
    const dir = "docs/tech-choices"; fs.mkdirSync(dir, { recursive: true });
    const fname = \`TCR-planning-\${new Date().toISOString().slice(0,10)}.md\`;
    fs.writeFileSync(path.join(dir, fname), ctx.last_assistant_text || "", "utf8");
    ctx.logs?.info?.("Wrote " + path.join(dir, fname));

</step>

<step number="3" name="force_cleaning_mode">
  EXECUTE_TS: |
    import { pushMode } from "./agent-os/lib/mode";
    pushMode(ctx, "cleaning");
</step>

<step number="3A" name="cleaning_execution">
  # CLEANING (Sonnet) — produce diffs/commands/checklists
  INVOKE_LLM:
    - system: |
        Active mode: cleaning
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['cleaning']") }}
        Output concrete unified diffs, exact commands, and batch checklists.
        Keep commentary minimal. Separate PRs per batch.
      user: |
        Using the validated plan, produce:
        - Branch names: chore/clean-*
        - File-level changes as unified diffs (per batch)
        - Lint/format + dependency pruning commands
        - Dry-run checklist per batch
        - CI notes for Angular/.NET/Playwright impacts

</step>

<step number="4" name="implementing_touchups">
  EXECUTE_TS: |
    import { pushMode } from "./agent-os/lib/mode";
    pushMode(ctx, "implementing");
  INVOKE_LLM:
    - system: |
        Active mode: implementing
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['implementing']") }}
        Emit tiny refactor diffs only (≤50 lines). No sweeping rewrites.
      user: |
        If cleaning revealed trivial refactors (rename symbols, fix imports), emit minimal diffs now.
</step>

<step number="5" name="pop_back_modes">
  EXECUTE_TS: |
    import { popMode } from "./agent-os/lib/mode";
    popMode(ctx); popMode(ctx); // back to initial mode

</step>

<step number="6" name="handoff">
  INVOKE_LLM:
    - system: |
        Active mode: documenting
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['documenting']") }}
      user: |
        Create a PR description template:
        - Title, Summary
        - Batches checklist
        - Risk & rollback plan
        - CI expectations & how to rerun
        - Links to evidence (grep/call-graphs)
</step>

</process_flow>

# =========================================
# Flow B: Branch Reconciler
# =========================================
<process_flow id="branch_reconciler">

<step number="0" name="mode_router">
  EXECUTE: @./agent-os/steps/mode-router.ts
</step>

<step number="0.5" name="collect_branch_facts">
  # Provide repo/base/head via inputs/vars when starting this flow
  EXECUTE: @./agent-os/steps/branch-collect.ts { "repo": "{{ repo }}", "base": "{{ base }}", "head": "{{ head }}", "feBuild": false, "dotnet": false }
</step>

<step number="1" name="analyze_deltas">
  # RECONCILING (Opus) — choose KEEP/KEEP/RECONCILE per area
  INVOKE_LLM:
    - system: |
        Active mode: reconciling
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['reconciling']") }}
        Also apply PLANNING tradeoff habits briefly.
      user: |
        Facts:
        - mergeBase: {{ mergeBase }}
        - conflicts: |
            {{ conflictsDryRun }}
        - diffBase: |
            {{ diffStatBase }}
        - diffHead: |
            {{ diffStatHead }}

        Deliver:
        1) Feature delta matrix:
           | Area | Base summary | Head summary | Perf/test notes | Choice (KEEP base/KEEP head/RECONCILE) | Rationale |
        2) Standards/spec adherence notes (per branch deviations).
        3) Risk list: textual vs functional conflicts.
        4) Merge strategy: rebase vs merge; order of operations.
        5) “Most advanced features” to prefer and why.

</step>

<step number="2" name="conflict_map">
  # TROUBLESHOOTING (Opus) — enumerate conflict hotspots precisely
  INVOKE_LLM:
    - system: |
        Active mode: troubleshooting
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['troubleshooting']") }}
      user: |
        Produce a conflict map:
        | File | Conflict type (textual/functional) | Tactic (ours/theirs/manual/feature-flag) | Owner |
        End with a 5–10 step execution plan.

</step>

<step number="3" name="emit_merge_steps_and_patches">
  # IMPLEMENTING (Sonnet) — commands + minimal patches
  INVOKE_LLM:
    - system: |
        Active mode: implementing
        {{ js("@./agent-os/prompts/mode-overlays.ts", "MODE_OVERLAYS['implementing']") }}
        Output exact commands, minimal diffs, and TODOs. No essays.
      user: |
        Emit:
        - Start from {{ base }}:
          git fetch --all
          git checkout {{ base }}
          git checkout -b chore/reconcile-{{ base }}...{{ head }}
        - Dry-run merge then resolve per conflict map.
        - For RECONCILE rows, output unified diffs combining best parts.
        - Add temporary feature flags where both variants must coexist.
        - Post-merge cleanup tasks (lint/format/refactor).
</step>

<step number="4" name="verification_block">
  # IMPLEMENTING (Sonnet) — verification script
  INVOKE_LLM:
    - system: |
        Active mode: implementing
      user: |
        Provide a single “verification” block:
        - .NET: build + tests (timed)
        - Frontend: build with stats + Playwright smoke
        - Perf sanity: simple BenchmarkDotNet or Lighthouse CLI
        - Exit criteria checklist

</step>

<step number="5" name="write_reports">
  EXECUTE_TS: |
    import * as fs from "node:fs"; import * as path from "node:path";
    fs.mkdirSync("docs/reports", { recursive: true });
    const cmp = \`branch-compare-{{ base }}...{{ head }}.md\`;
    const plan = \`merge-plan-{{ base }}...{{ head }}.md\`;
    // Save last two assistant messages (conflict map + commands/verification) into reports
    const a = ctx.history?.slice(-3) || [];
    const text = a.map(x => x.role === "assistant" ? x.text : "").filter(Boolean).join("\\n\\n---\\n\\n");
    fs.writeFileSync(path.join("docs/reports", cmp), text, "utf8");
    fs.writeFileSync(path.join("docs/reports", plan), text, "utf8");
    ctx.logs?.info?.("Wrote docs/reports/" + cmp + " and " + plan);

</step>

</process_flow>
