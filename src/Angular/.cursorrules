# Angular Frontend - Clean Architecture UI Layer

## Project Context
This is the Angular frontend application that consumes the ASP.NET Core Web API. It follows Angular best practices and integrates with the backend through HTTP services.

## Architecture Guidelines
- Follow Angular style guide and best practices
- Use standalone components (Angular 14+) for better tree-shaking
- Implement proper separation of concerns with services, components, and models
- Use reactive programming with RxJS observables
- Follow component-service-model architecture pattern

## Component Guidelines
- Keep components focused on presentation logic
- Use OnPush change detection strategy where possible
- Implement proper lifecycle hooks (OnInit, OnDestroy, etc.)
- Use async pipe for observable subscriptions
- Keep templates simple and readable
- Use trackBy functions for *ngFor performance

## Service Guidelines
- Create services for API communication and business logic
- Use HttpClient with proper error handling
- Implement proper typing with TypeScript interfaces
- Use RxJS operators for data transformation
- Handle loading states and error scenarios
- Cache data where appropriate

## Code Standards
- Use TypeScript strict mode
- Follow consistent naming conventions (camelCase, PascalCase)
- Use proper typing - avoid 'any' type
- Implement proper error handling with try-catch or RxJS catchError
- Use async/await or observables consistently
- Follow single responsibility principle

## API Integration
- Create typed interfaces for API responses
- Use environment configuration for API base URLs
- Implement proper HTTP interceptors for common concerns
- Handle authentication tokens if required
- Use proxy configuration for development (proxy.conf.json)
- Implement proper error handling for HTTP requests

## State Management
- Use services with BehaviorSubject for simple state management
- Consider NgRx for complex state management needs
- Implement proper data flow patterns
- Use reactive forms for form handling
- Handle form validation consistently

## Testing
- Write unit tests for components and services
- Use TestBed for component testing
- Mock HTTP requests with HttpClientTestingModule
- Test user interactions and component behavior
- Use Jasmine and Karma for unit testing
- Write E2E tests in the Tests.E2E.NG project

## Performance
- Use OnPush change detection strategy
- Implement lazy loading for feature modules
- Use trackBy functions for lists
- Optimize bundle size with proper imports
- Use async pipe to avoid manual subscriptions
- Implement proper unsubscription patterns

## UI/UX Guidelines
- Follow consistent design patterns
- Implement responsive design
- Use proper accessibility attributes
- Handle loading and error states gracefully
- Provide user feedback for actions
- Use Angular Material or similar UI library consistently

## File Organization
- app/ - Main application components and services
- components/ - Reusable UI components
- services/ - Business logic and API services
- models/ - TypeScript interfaces and types
- guards/ - Route guards for authentication/authorization
- interceptors/ - HTTP interceptors
- environments/ - Environment-specific configuration

## Example Patterns
```typescript
// Service with proper typing
@Injectable({ providedIn: 'root' })
export class PeopleService {
  constructor(private http: HttpClient) {}
  
  getPeople(): Observable<Person[]> {
    return this.http.get<Person[]>('/api/people')
      .pipe(
        catchError(this.handleError)
      );
  }
  
  private handleError(error: HttpErrorResponse): Observable<never> {
    console.error('API Error:', error);
    return throwError(() => new Error('Something went wrong'));
  }
}

// Component with OnPush and async pipe
@Component({
  selector: 'app-people-list',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngFor="let person of people$ | async; trackBy: trackByPersonId">
      {{ person.name }}
    </div>
  `
})
export class PeopleListComponent implements OnInit {
  people$ = this.peopleService.getPeople();
  
  constructor(private peopleService: PeopleService) {}
  
  trackByPersonId(index: number, person: Person): number {
    return person.id;
  }
}
```

## Development Tools
- Use Angular CLI for project management
- Configure ESLint for code quality
- Use Prettier for code formatting
- Set up proper debugging in VS Code
- Use Angular DevTools for debugging
