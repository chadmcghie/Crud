# .NET MAUI Cross-Platform Application

## Project Context
This is a .NET MAUI (Multi-platform App UI) application that provides native mobile and desktop experiences. It can consume the same backend APIs as the Angular frontend.

## Architecture Guidelines
- Follow MVVM (Model-View-ViewModel) pattern
- Use data binding for UI updates
- Implement proper separation of concerns
- Use dependency injection for services and ViewModels
- Follow platform-specific guidelines while sharing common code

## MVVM Pattern
- **Models**: Data structures and business objects
- **Views**: XAML pages and UI components
- **ViewModels**: Presentation logic and data binding
- Use INotifyPropertyChanged for property change notifications
- Implement ICommand for user actions and button clicks
- Use ObservableCollection for dynamic lists

## Code Standards
- Use async/await for all I/O operations
- Implement proper error handling and user feedback
- Follow C# naming conventions
- Use proper data binding with XAML
- Implement navigation patterns consistently
- Handle platform-specific code appropriately

## UI Guidelines
- Use XAML for UI definition
- Implement responsive layouts that work across platforms
- Use proper styling and theming
- Handle different screen sizes and orientations
- Follow platform-specific design guidelines (Material Design, Human Interface Guidelines)
- Implement proper accessibility features

## Data Access
- Create services for API communication
- Use HttpClient for REST API calls
- Implement proper error handling for network requests
- Use JSON serialization for API communication
- Handle offline scenarios gracefully
- Implement proper caching strategies

## Platform Integration
- Use platform-specific features through dependency injection
- Implement proper file system access
- Handle platform-specific permissions
- Use native platform APIs when needed
- Test on all target platforms (iOS, Android, Windows, macOS)

## Navigation
- Use Shell navigation for consistent navigation patterns
- Implement proper page lifecycle management
- Handle back button and navigation stack appropriately
- Use proper parameter passing between pages
- Implement deep linking if required

## Testing
- Write unit tests for ViewModels and services
- Use dependency injection for testability
- Mock external dependencies and services
- Test business logic in isolation
- Write UI tests for critical user workflows
- Test on multiple platforms and devices

## Performance
- Use async patterns to avoid blocking UI thread
- Implement proper image loading and caching
- Use virtualization for large lists
- Optimize startup time and memory usage
- Profile performance on target devices
- Use proper disposal patterns for resources

## Security
- Implement proper authentication and authorization
- Store sensitive data securely (Secure Storage)
- Use HTTPS for all API communications
- Validate all user inputs
- Handle authentication tokens securely
- Follow platform security guidelines

## File Organization
- Views/ - XAML pages and user controls
- ViewModels/ - Presentation logic and data binding
- Models/ - Data structures and business objects
- Services/ - API communication and business services
- Platforms/ - Platform-specific implementations
- Resources/ - Images, fonts, and other assets
- Styles/ - XAML styles and themes

## Example Patterns
```csharp
// ViewModel with proper MVVM implementation
public class PeopleViewModel : INotifyPropertyChanged
{
    private readonly IPeopleService _peopleService;
    private ObservableCollection<Person> _people;
    
    public PeopleViewModel(IPeopleService peopleService)
    {
        _peopleService = peopleService;
        LoadPeopleCommand = new Command(async () => await LoadPeople());
    }
    
    public ObservableCollection<Person> People
    {
        get => _people;
        set
        {
            _people = value;
            OnPropertyChanged();
        }
    }
    
    public ICommand LoadPeopleCommand { get; }
    
    private async Task LoadPeople()
    {
        try
        {
            var people = await _peopleService.GetPeopleAsync();
            People = new ObservableCollection<Person>(people);
        }
        catch (Exception ex)
        {
            // Handle error and show user feedback
            await Application.Current.MainPage.DisplayAlert("Error", ex.Message, "OK");
        }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

## Development Tools
- Use Visual Studio 2022 or VS Code with C# extension
- Use XAML Hot Reload for faster development
- Configure proper debugging for target platforms
- Use device emulators and physical devices for testing
- Set up proper build and deployment pipelines
